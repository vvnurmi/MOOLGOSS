/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package com.moolgoss.service {

import org.apache.thrift.Set;
import flash.utils.ByteArray;
import flash.utils.Dictionary;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;


  public class MOOServiceImpl implements MOOService {
    public function MOOServiceImpl(iprot:TProtocol, oprot:TProtocol=null)
    {
      iprot_ = iprot;
      if (oprot == null) {
        oprot_ = iprot;
      } else {
        oprot_ = oprot;
      }    }

    protected var iprot_:TProtocol;
    protected var oprot_:TProtocol;

    protected var seqid_:int;

    public function getInputProtocol():TProtocol
    {
      return this.iprot_;
    }

    public function getOutputProtocol():TProtocol
    {
      return this.oprot_;
    }

    //function onError(Error):void;
    //function onSuccess():void;
    public function Authenticate(name:String, onError:Function, onSuccess:Function):void
    {
      oprot_.writeMessageBegin(new TMessage("Authenticate", TMessageType.CALL, seqid_));
      var args:Authenticate_args = new Authenticate_args();
      args.name = name;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush(function(error:Error):void {
        try {
          if (error != null) {
            if (onError != null) onError(error);
            return;
          }
          var msg:TMessage = iprot_.readMessageBegin();
          if (msg.type == TMessageType.EXCEPTION) {
            var x:TApplicationError = TApplicationError.read(iprot_);
            iprot_.readMessageEnd();
            if (onError != null) onError(x);
            return;
          }
          var result :Authenticate_result = new Authenticate_result();
          result.read(iprot_);
          iprot_.readMessageEnd();
          if (onSuccess != null) onSuccess();
          return;
        } catch (e:TError) {
          if (onError != null) onError(e);
        }
      });
    }

    //function onError(Error):void;
    //function onSuccess(UpdateData):void;
    public function GetUpdate(onError:Function, onSuccess:Function):void
    {
      oprot_.writeMessageBegin(new TMessage("GetUpdate", TMessageType.CALL, seqid_));
      var args:GetUpdate_args = new GetUpdate_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush(function(error:Error):void {
        try {
          if (error != null) {
            if (onError != null) onError(error);
            return;
          }
          var msg:TMessage = iprot_.readMessageBegin();
          if (msg.type == TMessageType.EXCEPTION) {
            var x:TApplicationError = TApplicationError.read(iprot_);
            iprot_.readMessageEnd();
            if (onError != null) onError(x);
            return;
          }
          var result :GetUpdate_result = new GetUpdate_result();
          result.read(iprot_);
          iprot_.readMessageEnd();
          if (result.isSetSuccess()) {
            if (onSuccess != null) onSuccess(result.success);
            return;
          }
          if (onError != null) onError(new TApplicationError(TApplicationError.MISSING_RESULT, "GetUpdate failed: unknown result"));
        } catch (e:TError) {
          if (onError != null) onError(e);
        }
      });
    }

    //function onError(Error):void;
    //function onSuccess(Array):void;
    public function GetPlanets(onError:Function, onSuccess:Function):void
    {
      oprot_.writeMessageBegin(new TMessage("GetPlanets", TMessageType.CALL, seqid_));
      var args:GetPlanets_args = new GetPlanets_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush(function(error:Error):void {
        try {
          if (error != null) {
            if (onError != null) onError(error);
            return;
          }
          var msg:TMessage = iprot_.readMessageBegin();
          if (msg.type == TMessageType.EXCEPTION) {
            var x:TApplicationError = TApplicationError.read(iprot_);
            iprot_.readMessageEnd();
            if (onError != null) onError(x);
            return;
          }
          var result :GetPlanets_result = new GetPlanets_result();
          result.read(iprot_);
          iprot_.readMessageEnd();
          if (result.isSetSuccess()) {
            if (onSuccess != null) onSuccess(result.success);
            return;
          }
          if (onError != null) onError(new TApplicationError(TApplicationError.MISSING_RESULT, "GetPlanets failed: unknown result"));
        } catch (e:TError) {
          if (onError != null) onError(e);
        }
      });
    }

    //function onError(Error):void;
    //function onSuccess(Array):void;
    public function GetFormations(onError:Function, onSuccess:Function):void
    {
      oprot_.writeMessageBegin(new TMessage("GetFormations", TMessageType.CALL, seqid_));
      var args:GetFormations_args = new GetFormations_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush(function(error:Error):void {
        try {
          if (error != null) {
            if (onError != null) onError(error);
            return;
          }
          var msg:TMessage = iprot_.readMessageBegin();
          if (msg.type == TMessageType.EXCEPTION) {
            var x:TApplicationError = TApplicationError.read(iprot_);
            iprot_.readMessageEnd();
            if (onError != null) onError(x);
            return;
          }
          var result :GetFormations_result = new GetFormations_result();
          result.read(iprot_);
          iprot_.readMessageEnd();
          if (result.isSetSuccess()) {
            if (onSuccess != null) onSuccess(result.success);
            return;
          }
          if (onError != null) onError(new TApplicationError(TApplicationError.MISSING_RESULT, "GetFormations failed: unknown result"));
        } catch (e:TError) {
          if (onError != null) onError(e);
        }
      });
    }

    //function onError(Error):void;
    //function onSuccess():void;
    public function IssueCommand(command:Command, onError:Function, onSuccess:Function):void
    {
      oprot_.writeMessageBegin(new TMessage("IssueCommand", TMessageType.CALL, seqid_));
      var args:IssueCommand_args = new IssueCommand_args();
      args.command = command;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush(function(error:Error):void {
        try {
          if (error != null) {
            if (onError != null) onError(error);
            return;
          }
          var msg:TMessage = iprot_.readMessageBegin();
          if (msg.type == TMessageType.EXCEPTION) {
            var x:TApplicationError = TApplicationError.read(iprot_);
            iprot_.readMessageEnd();
            if (onError != null) onError(x);
            return;
          }
          var result :IssueCommand_result = new IssueCommand_result();
          result.read(iprot_);
          iprot_.readMessageEnd();
          if (onSuccess != null) onSuccess();
          return;
        } catch (e:TError) {
          if (onError != null) onError(e);
        }
      });
    }

  }
}
import org.apache.thrift.Set;
import flash.utils.ByteArray;
import flash.utils.Dictionary;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;

import com.moolgoss.service.*;
class Authenticate_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("Authenticate_args");
  private static const NAME_FIELD_DESC:TField = new TField("name", TType.STRING, 1);

  private var _name:String;
  public static const NAME:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[NAME] = new FieldMetaData("name", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(Authenticate_args, metaDataMap);
  }

  public function Authenticate_args() {
  }

  public function get name():String {
    return this._name;
  }

  public function set name(name:String):void {
    this._name = name;
  }

  public function unsetName():void {
    this.name = null;
  }

  // Returns true if field name is set (has been assigned a value) and false otherwise
  public function isSetName():Boolean {
    return this.name != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case NAME:
      if (value == null) {
        unsetName();
      } else {
        this.name = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case NAME:
      return this.name;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case NAME:
      return isSetName();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case NAME:
          if (field.type == TType.STRING) {
            this.name = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.name != null) {
      oprot.writeFieldBegin(NAME_FIELD_DESC);
      oprot.writeString(this.name);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("Authenticate_args(");
    var first:Boolean = true;

    ret += "name:";
    if (this.name == null) {
      ret += "null";
    } else {
      ret += this.name;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class Authenticate_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("Authenticate_result");



  public static const metaDataMap:Dictionary = new Dictionary();
  {
    FieldMetaData.addStructMetaDataMap(Authenticate_result, metaDataMap);
  }

  public function Authenticate_result() {
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("Authenticate_result(");
    var first:Boolean = true;

    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetUpdate_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetUpdate_args");



  public static const metaDataMap:Dictionary = new Dictionary();
  {
    FieldMetaData.addStructMetaDataMap(GetUpdate_args, metaDataMap);
  }

  public function GetUpdate_args() {
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetUpdate_args(");
    var first:Boolean = true;

    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetUpdate_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetUpdate_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);

  private var _success:UpdateData;
  public static const SUCCESS:int = 0;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, UpdateData));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetUpdate_result, metaDataMap);
  }

  public function GetUpdate_result() {
  }

  public function get success():UpdateData {
    return this._success;
  }

  public function set success(success:UpdateData):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new UpdateData();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetUpdate_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetPlanets_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetPlanets_args");



  public static const metaDataMap:Dictionary = new Dictionary();
  {
    FieldMetaData.addStructMetaDataMap(GetPlanets_args, metaDataMap);
  }

  public function GetPlanets_args() {
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetPlanets_args(");
    var first:Boolean = true;

    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetPlanets_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetPlanets_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.LIST, 0);

  private var _success:Array;
  public static const SUCCESS:int = 0;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new ListMetaData(TType.LIST, 
            new StructMetaData(TType.STRUCT, Planet)));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetPlanets_result, metaDataMap);
  }

  public function GetPlanets_result() {
  }

  public function get success():Array {
    return this._success;
  }

  public function set success(success:Array):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              var _list27:TList = iprot.readListBegin();
              this.success = new Array();
              for (var _i28:int = 0; _i28 < _list27.size; ++_i28)
              {
                var _elem29:Planet;
                _elem29 = new Planet();
                _elem29.read(iprot);
                this.success.push(_elem29);
              }
              iprot.readListEnd();
            }
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for each (var elem30:* in this.success)        {
          elem30.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetPlanets_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetFormations_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetFormations_args");



  public static const metaDataMap:Dictionary = new Dictionary();
  {
    FieldMetaData.addStructMetaDataMap(GetFormations_args, metaDataMap);
  }

  public function GetFormations_args() {
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetFormations_args(");
    var first:Boolean = true;

    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetFormations_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetFormations_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.LIST, 0);

  private var _success:Array;
  public static const SUCCESS:int = 0;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new ListMetaData(TType.LIST, 
            new StructMetaData(TType.STRUCT, Formation)));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetFormations_result, metaDataMap);
  }

  public function GetFormations_result() {
  }

  public function get success():Array {
    return this._success;
  }

  public function set success(success:Array):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              var _list32:TList = iprot.readListBegin();
              this.success = new Array();
              for (var _i33:int = 0; _i33 < _list32.size; ++_i33)
              {
                var _elem34:Formation;
                _elem34 = new Formation();
                _elem34.read(iprot);
                this.success.push(_elem34);
              }
              iprot.readListEnd();
            }
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for each (var elem35:* in this.success)        {
          elem35.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetFormations_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class IssueCommand_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("IssueCommand_args");
  private static const COMMAND_FIELD_DESC:TField = new TField("command", TType.STRUCT, 1);

  private var _command:Command;
  public static const COMMAND:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[COMMAND] = new FieldMetaData("command", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, Command));
  }
  {
    FieldMetaData.addStructMetaDataMap(IssueCommand_args, metaDataMap);
  }

  public function IssueCommand_args() {
  }

  public function get command():Command {
    return this._command;
  }

  public function set command(command:Command):void {
    this._command = command;
  }

  public function unsetCommand():void {
    this.command = null;
  }

  // Returns true if field command is set (has been assigned a value) and false otherwise
  public function isSetCommand():Boolean {
    return this.command != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case COMMAND:
      if (value == null) {
        unsetCommand();
      } else {
        this.command = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case COMMAND:
      return this.command;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case COMMAND:
      return isSetCommand();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case COMMAND:
          if (field.type == TType.STRUCT) {
            this.command = new Command();
            this.command.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.command != null) {
      oprot.writeFieldBegin(COMMAND_FIELD_DESC);
      this.command.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("IssueCommand_args(");
    var first:Boolean = true;

    ret += "command:";
    if (this.command == null) {
      ret += "null";
    } else {
      ret += this.command;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class IssueCommand_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("IssueCommand_result");



  public static const metaDataMap:Dictionary = new Dictionary();
  {
    FieldMetaData.addStructMetaDataMap(IssueCommand_result, metaDataMap);
  }

  public function IssueCommand_result() {
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("IssueCommand_result(");
    var first:Boolean = true;

    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

