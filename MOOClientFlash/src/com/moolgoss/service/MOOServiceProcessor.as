/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package com.moolgoss.service {

import org.apache.thrift.Set;
import flash.utils.ByteArray;
import flash.utils.Dictionary;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;


  public class MOOServiceProcessor implements TProcessor {
    public function MOOServiceProcessor(iface:MOOService)
    {
      iface_ = iface;
      PROCESS_MAP["Authenticate"] = Authenticate();
      PROCESS_MAP["GetUpdate"] = GetUpdate();
      PROCESS_MAP["GetPlanets"] = GetPlanets();
      PROCESS_MAP["GetFormations"] = GetFormations();
      PROCESS_MAP["IssueCommand"] = IssueCommand();
    }

    private var iface_:MOOService;
    protected const PROCESS_MAP:Dictionary = new Dictionary();

    public function process(iprot:TProtocol, oprot:TProtocol):Boolean
    {
      var msg:TMessage = iprot.readMessageBegin();
      var fn:Function = PROCESS_MAP[msg.name];
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        var x:TApplicationError = new TApplicationError(TApplicationError.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.call(this,msg.seqid, iprot, oprot);
      return true;
    }

    private function Authenticate():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:Authenticate_args = new Authenticate_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:Authenticate_result = new Authenticate_result();
        // sorry this operation is not supported yet
        throw new Error("This is not yet supported");
        oprot.writeMessageBegin(new TMessage("Authenticate", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function GetUpdate():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:GetUpdate_args = new GetUpdate_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:GetUpdate_result = new GetUpdate_result();
        // sorry this operation is not supported yet
        throw new Error("This is not yet supported");
        oprot.writeMessageBegin(new TMessage("GetUpdate", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function GetPlanets():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:GetPlanets_args = new GetPlanets_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:GetPlanets_result = new GetPlanets_result();
        // sorry this operation is not supported yet
        throw new Error("This is not yet supported");
        oprot.writeMessageBegin(new TMessage("GetPlanets", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function GetFormations():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:GetFormations_args = new GetFormations_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:GetFormations_result = new GetFormations_result();
        // sorry this operation is not supported yet
        throw new Error("This is not yet supported");
        oprot.writeMessageBegin(new TMessage("GetFormations", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function IssueCommand():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:IssueCommand_args = new IssueCommand_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:IssueCommand_result = new IssueCommand_result();
        // sorry this operation is not supported yet
        throw new Error("This is not yet supported");
        oprot.writeMessageBegin(new TMessage("IssueCommand", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

  }

}
import org.apache.thrift.Set;
import flash.utils.ByteArray;
import flash.utils.Dictionary;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;


import com.moolgoss.service.*;
class Authenticate_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("Authenticate_args");
  private static const NAME_FIELD_DESC:TField = new TField("name", TType.STRING, 1);

  private var _name:String;
  public static const NAME:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[NAME] = new FieldMetaData("name", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(Authenticate_args, metaDataMap);
  }

  public function Authenticate_args() {
  }

  public function get name():String {
    return this._name;
  }

  public function set name(name:String):void {
    this._name = name;
  }

  public function unsetName():void {
    this.name = null;
  }

  // Returns true if field name is set (has been assigned a value) and false otherwise
  public function isSetName():Boolean {
    return this.name != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case NAME:
      if (value == null) {
        unsetName();
      } else {
        this.name = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case NAME:
      return this.name;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case NAME:
      return isSetName();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case NAME:
          if (field.type == TType.STRING) {
            this.name = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.name != null) {
      oprot.writeFieldBegin(NAME_FIELD_DESC);
      oprot.writeString(this.name);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("Authenticate_args(");
    var first:Boolean = true;

    ret += "name:";
    if (this.name == null) {
      ret += "null";
    } else {
      ret += this.name;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class Authenticate_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("Authenticate_result");



  public static const metaDataMap:Dictionary = new Dictionary();
  {
    FieldMetaData.addStructMetaDataMap(Authenticate_result, metaDataMap);
  }

  public function Authenticate_result() {
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("Authenticate_result(");
    var first:Boolean = true;

    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetUpdate_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetUpdate_args");



  public static const metaDataMap:Dictionary = new Dictionary();
  {
    FieldMetaData.addStructMetaDataMap(GetUpdate_args, metaDataMap);
  }

  public function GetUpdate_args() {
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetUpdate_args(");
    var first:Boolean = true;

    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetUpdate_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetUpdate_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);

  private var _success:UpdateData;
  public static const SUCCESS:int = 0;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, UpdateData));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetUpdate_result, metaDataMap);
  }

  public function GetUpdate_result() {
  }

  public function get success():UpdateData {
    return this._success;
  }

  public function set success(success:UpdateData):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new UpdateData();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetUpdate_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetPlanets_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetPlanets_args");



  public static const metaDataMap:Dictionary = new Dictionary();
  {
    FieldMetaData.addStructMetaDataMap(GetPlanets_args, metaDataMap);
  }

  public function GetPlanets_args() {
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetPlanets_args(");
    var first:Boolean = true;

    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetPlanets_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetPlanets_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.LIST, 0);

  private var _success:Array;
  public static const SUCCESS:int = 0;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new ListMetaData(TType.LIST, 
            new StructMetaData(TType.STRUCT, Planet)));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetPlanets_result, metaDataMap);
  }

  public function GetPlanets_result() {
  }

  public function get success():Array {
    return this._success;
  }

  public function set success(success:Array):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              var _list40:TList = iprot.readListBegin();
              this.success = new Array();
              for (var _i41:int = 0; _i41 < _list40.size; ++_i41)
              {
                var _elem42:Planet;
                _elem42 = new Planet();
                _elem42.read(iprot);
                this.success.push(_elem42);
              }
              iprot.readListEnd();
            }
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for each (var elem43:* in this.success)        {
          elem43.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetPlanets_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetFormations_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetFormations_args");



  public static const metaDataMap:Dictionary = new Dictionary();
  {
    FieldMetaData.addStructMetaDataMap(GetFormations_args, metaDataMap);
  }

  public function GetFormations_args() {
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetFormations_args(");
    var first:Boolean = true;

    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetFormations_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetFormations_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.LIST, 0);

  private var _success:Array;
  public static const SUCCESS:int = 0;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new ListMetaData(TType.LIST, 
            new StructMetaData(TType.STRUCT, Formation)));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetFormations_result, metaDataMap);
  }

  public function GetFormations_result() {
  }

  public function get success():Array {
    return this._success;
  }

  public function set success(success:Array):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              var _list45:TList = iprot.readListBegin();
              this.success = new Array();
              for (var _i46:int = 0; _i46 < _list45.size; ++_i46)
              {
                var _elem47:Formation;
                _elem47 = new Formation();
                _elem47.read(iprot);
                this.success.push(_elem47);
              }
              iprot.readListEnd();
            }
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for each (var elem48:* in this.success)        {
          elem48.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetFormations_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class IssueCommand_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("IssueCommand_args");
  private static const COMMAND_FIELD_DESC:TField = new TField("command", TType.STRUCT, 1);

  private var _command:Command;
  public static const COMMAND:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[COMMAND] = new FieldMetaData("command", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, Command));
  }
  {
    FieldMetaData.addStructMetaDataMap(IssueCommand_args, metaDataMap);
  }

  public function IssueCommand_args() {
  }

  public function get command():Command {
    return this._command;
  }

  public function set command(command:Command):void {
    this._command = command;
  }

  public function unsetCommand():void {
    this.command = null;
  }

  // Returns true if field command is set (has been assigned a value) and false otherwise
  public function isSetCommand():Boolean {
    return this.command != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case COMMAND:
      if (value == null) {
        unsetCommand();
      } else {
        this.command = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case COMMAND:
      return this.command;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case COMMAND:
      return isSetCommand();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case COMMAND:
          if (field.type == TType.STRUCT) {
            this.command = new Command();
            this.command.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.command != null) {
      oprot.writeFieldBegin(COMMAND_FIELD_DESC);
      this.command.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("IssueCommand_args(");
    var first:Boolean = true;

    ret += "command:";
    if (this.command == null) {
      ret += "null";
    } else {
      ret += this.command;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class IssueCommand_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("IssueCommand_result");



  public static const metaDataMap:Dictionary = new Dictionary();
  {
    FieldMetaData.addStructMetaDataMap(IssueCommand_result, metaDataMap);
  }

  public function IssueCommand_result() {
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("IssueCommand_result(");
    var first:Boolean = true;

    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

