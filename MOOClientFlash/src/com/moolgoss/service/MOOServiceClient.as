/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package com.moolgoss.service {

  import flash.utils.ByteArray;
  import flash.utils.Dictionary;

  import org.apache.thrift.*;
  import org.apache.thrift.meta_data.*;
  import org.apache.thrift.protocol.*;


  public class MOOServiceClient {

    protected var processor:TProcessor;

    public function MOOServiceClient(processor:TProcessor)
    {
      this.processor = processor;
    }

    public function send_Authenticate(name:String, onSuccess:Function=null, onError:Function=null):TAsyncResult
    {
      processor.seqid += 1;
      var asyncResult:TAsyncResult = processor.requestMap[processor.seqid] = new TAsyncResult(this.recv_Authenticate);
      if(onSuccess != null) asyncResult.Callback = onSuccess;
      if(onError != null) asyncResult.Errback = onError;
      try
      {
        processor.oprot.writeMessageBegin(new TMessage("Authenticate", TMessageType.CALL, processor.seqid));
        var args:Authenticate_args = new Authenticate_args();
        args.name = name;
        args.write(processor.oprot);
        processor.oprot.writeMessageEnd();
        processor.oprot.getTransport().flush();
      }
      catch(e:TError) {
        if(onError != null) onError(e);
      }
      return asyncResult;
    }

    public function recv_Authenticate(msg:TMessage,asyncResult:TAsyncResult):void
    {
      try {
        if (msg.type == TMessageType.EXCEPTION) {
          var x:TApplicationError = TApplicationError.read(processor.iprot);
          processor.iprot.readMessageEnd();
          if (asyncResult.Errback != null) asyncResult.Errback(x);
          return;
        }
        var result:Authenticate_result = new Authenticate_result();
        result.read(processor.iprot);
        processor.iprot.readMessageEnd();
        if (asyncResult.Callback != null) asyncResult.Callback();
        return;
      }
      catch(e:TError) {
        if (asyncResult.Errback != null) asyncResult.Errback(e);
      }
    }

    public function send_GetUpdate(onSuccess:Function=null, onError:Function=null):TAsyncResult
    {
      processor.seqid += 1;
      var asyncResult:TAsyncResult = processor.requestMap[processor.seqid] = new TAsyncResult(this.recv_GetUpdate);
      if(onSuccess != null) asyncResult.Callback = onSuccess;
      if(onError != null) asyncResult.Errback = onError;
      try
      {
        processor.oprot.writeMessageBegin(new TMessage("GetUpdate", TMessageType.CALL, processor.seqid));
        var args:GetUpdate_args = new GetUpdate_args();
        args.write(processor.oprot);
        processor.oprot.writeMessageEnd();
        processor.oprot.getTransport().flush();
      }
      catch(e:TError) {
        if(onError != null) onError(e);
      }
      return asyncResult;
    }

    public function recv_GetUpdate(msg:TMessage,asyncResult:TAsyncResult):void
    {
      try {
        if (msg.type == TMessageType.EXCEPTION) {
          var x:TApplicationError = TApplicationError.read(processor.iprot);
          processor.iprot.readMessageEnd();
          if (asyncResult.Errback != null) asyncResult.Errback(x);
          return;
        }
        var result:GetUpdate_result = new GetUpdate_result();
        result.read(processor.iprot);
        processor.iprot.readMessageEnd();
        if (result.isSetSuccess()) {
          if (asyncResult.Callback != null) asyncResult.Callback(result.success);
          return;
        }
        if (asyncResult.Errback != null) asyncResult.Errback(new TApplicationError(TApplicationError.MISSING_RESULT, "GetUpdate failed: unknown result"));
      }
      catch(e:TError) {
        if (asyncResult.Errback != null) asyncResult.Errback(e);
      }
    }

    public function send_GetPlanets(onSuccess:Function=null, onError:Function=null):TAsyncResult
    {
      processor.seqid += 1;
      var asyncResult:TAsyncResult = processor.requestMap[processor.seqid] = new TAsyncResult(this.recv_GetPlanets);
      if(onSuccess != null) asyncResult.Callback = onSuccess;
      if(onError != null) asyncResult.Errback = onError;
      try
      {
        processor.oprot.writeMessageBegin(new TMessage("GetPlanets", TMessageType.CALL, processor.seqid));
        var args:GetPlanets_args = new GetPlanets_args();
        args.write(processor.oprot);
        processor.oprot.writeMessageEnd();
        processor.oprot.getTransport().flush();
      }
      catch(e:TError) {
        if(onError != null) onError(e);
      }
      return asyncResult;
    }

    public function recv_GetPlanets(msg:TMessage,asyncResult:TAsyncResult):void
    {
      try {
        if (msg.type == TMessageType.EXCEPTION) {
          var x:TApplicationError = TApplicationError.read(processor.iprot);
          processor.iprot.readMessageEnd();
          if (asyncResult.Errback != null) asyncResult.Errback(x);
          return;
        }
        var result:GetPlanets_result = new GetPlanets_result();
        result.read(processor.iprot);
        processor.iprot.readMessageEnd();
        if (result.isSetSuccess()) {
          if (asyncResult.Callback != null) asyncResult.Callback(result.success);
          return;
        }
        if (asyncResult.Errback != null) asyncResult.Errback(new TApplicationError(TApplicationError.MISSING_RESULT, "GetPlanets failed: unknown result"));
      }
      catch(e:TError) {
        if (asyncResult.Errback != null) asyncResult.Errback(e);
      }
    }

    public function send_GetFormations(onSuccess:Function=null, onError:Function=null):TAsyncResult
    {
      processor.seqid += 1;
      var asyncResult:TAsyncResult = processor.requestMap[processor.seqid] = new TAsyncResult(this.recv_GetFormations);
      if(onSuccess != null) asyncResult.Callback = onSuccess;
      if(onError != null) asyncResult.Errback = onError;
      try
      {
        processor.oprot.writeMessageBegin(new TMessage("GetFormations", TMessageType.CALL, processor.seqid));
        var args:GetFormations_args = new GetFormations_args();
        args.write(processor.oprot);
        processor.oprot.writeMessageEnd();
        processor.oprot.getTransport().flush();
      }
      catch(e:TError) {
        if(onError != null) onError(e);
      }
      return asyncResult;
    }

    public function recv_GetFormations(msg:TMessage,asyncResult:TAsyncResult):void
    {
      try {
        if (msg.type == TMessageType.EXCEPTION) {
          var x:TApplicationError = TApplicationError.read(processor.iprot);
          processor.iprot.readMessageEnd();
          if (asyncResult.Errback != null) asyncResult.Errback(x);
          return;
        }
        var result:GetFormations_result = new GetFormations_result();
        result.read(processor.iprot);
        processor.iprot.readMessageEnd();
        if (result.isSetSuccess()) {
          if (asyncResult.Callback != null) asyncResult.Callback(result.success);
          return;
        }
        if (asyncResult.Errback != null) asyncResult.Errback(new TApplicationError(TApplicationError.MISSING_RESULT, "GetFormations failed: unknown result"));
      }
      catch(e:TError) {
        if (asyncResult.Errback != null) asyncResult.Errback(e);
      }
    }

    public function send_IssueCommand(command:Command, onSuccess:Function=null, onError:Function=null):TAsyncResult
    {
      processor.seqid += 1;
      var asyncResult:TAsyncResult = processor.requestMap[processor.seqid] = new TAsyncResult(this.recv_IssueCommand);
      if(onSuccess != null) asyncResult.Callback = onSuccess;
      if(onError != null) asyncResult.Errback = onError;
      try
      {
        processor.oprot.writeMessageBegin(new TMessage("IssueCommand", TMessageType.CALL, processor.seqid));
        var args:IssueCommand_args = new IssueCommand_args();
        args.command = command;
        args.write(processor.oprot);
        processor.oprot.writeMessageEnd();
        processor.oprot.getTransport().flush();
      }
      catch(e:TError) {
        if(onError != null) onError(e);
      }
      return asyncResult;
    }

    public function recv_IssueCommand(msg:TMessage,asyncResult:TAsyncResult):void
    {
      try {
        if (msg.type == TMessageType.EXCEPTION) {
          var x:TApplicationError = TApplicationError.read(processor.iprot);
          processor.iprot.readMessageEnd();
          if (asyncResult.Errback != null) asyncResult.Errback(x);
          return;
        }
        var result:IssueCommand_result = new IssueCommand_result();
        result.read(processor.iprot);
        processor.iprot.readMessageEnd();
        if (asyncResult.Callback != null) asyncResult.Callback();
        return;
      }
      catch(e:TError) {
        if (asyncResult.Errback != null) asyncResult.Errback(e);
      }
    }

  }
}


import flash.utils.ByteArray;
import flash.utils.Dictionary;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;

import com.moolgoss.service.*;
class Authenticate_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("Authenticate_args");
  private static const NAME_FIELD_DESC:TField = new TField("name", TType.STRING, 1);

  private var _name:String;
  public static const NAME:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[NAME] = new FieldMetaData("name", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(Authenticate_args, metaDataMap);
  }

  public function Authenticate_args() {
  }

  public function get name():String {
    return this._name;
  }

  public function set name(name:String):void {
    this._name = name;
  }

  public function unsetName():void {
    this.name = null;
  }

  // Returns true if field name is set (has been assigned a value) and false otherwise
  public function isSetName():Boolean {
    return this.name != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case NAME:
      if (value == null) {
        unsetName();
      } else {
        this.name = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case NAME:
      return this.name;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case NAME:
      return isSetName();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case NAME:
          if (field.type == TType.STRING) {
            this.name = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.name != null) {
      oprot.writeFieldBegin(NAME_FIELD_DESC);
      oprot.writeString(this.name);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("Authenticate_args(");
    var first:Boolean = true;

    ret += "name:";
    if (this.name == null) {
      ret += "null";
    } else {
      ret += this.name;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class Authenticate_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("Authenticate_result");



  public static const metaDataMap:Dictionary = new Dictionary();
  {
    FieldMetaData.addStructMetaDataMap(Authenticate_result, metaDataMap);
  }

  public function Authenticate_result() {
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("Authenticate_result(");
    var first:Boolean = true;

    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetUpdate_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetUpdate_args");



  public static const metaDataMap:Dictionary = new Dictionary();
  {
    FieldMetaData.addStructMetaDataMap(GetUpdate_args, metaDataMap);
  }

  public function GetUpdate_args() {
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetUpdate_args(");
    var first:Boolean = true;

    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetUpdate_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetUpdate_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);

  private var _success:UpdateData;
  public static const SUCCESS:int = 0;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, UpdateData));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetUpdate_result, metaDataMap);
  }

  public function GetUpdate_result() {
  }

  public function get success():UpdateData {
    return this._success;
  }

  public function set success(success:UpdateData):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new UpdateData();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetUpdate_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetPlanets_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetPlanets_args");



  public static const metaDataMap:Dictionary = new Dictionary();
  {
    FieldMetaData.addStructMetaDataMap(GetPlanets_args, metaDataMap);
  }

  public function GetPlanets_args() {
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetPlanets_args(");
    var first:Boolean = true;

    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetPlanets_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetPlanets_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.LIST, 0);

  private var _success:Array;
  public static const SUCCESS:int = 0;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new ListMetaData(TType.LIST, 
            new StructMetaData(TType.STRUCT, Planet)));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetPlanets_result, metaDataMap);
  }

  public function GetPlanets_result() {
  }

  public function get success():Array {
    return this._success;
  }

  public function set success(success:Array):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              var _list27:TList = iprot.readListBegin();
              this.success = new Array();
              for (var _i28:int = 0; _i28 < _list27.size; ++_i28)
              {
                var _elem29:Planet;
                _elem29 = new Planet();
                _elem29.read(iprot);
                this.success.push(_elem29);
              }
              iprot.readListEnd();
            }
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for each (var elem30:* in this.success)        {
          elem30.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetPlanets_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetFormations_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetFormations_args");



  public static const metaDataMap:Dictionary = new Dictionary();
  {
    FieldMetaData.addStructMetaDataMap(GetFormations_args, metaDataMap);
  }

  public function GetFormations_args() {
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetFormations_args(");
    var first:Boolean = true;

    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetFormations_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetFormations_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.LIST, 0);

  private var _success:Array;
  public static const SUCCESS:int = 0;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new ListMetaData(TType.LIST, 
            new StructMetaData(TType.STRUCT, Formation)));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetFormations_result, metaDataMap);
  }

  public function GetFormations_result() {
  }

  public function get success():Array {
    return this._success;
  }

  public function set success(success:Array):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              var _list32:TList = iprot.readListBegin();
              this.success = new Array();
              for (var _i33:int = 0; _i33 < _list32.size; ++_i33)
              {
                var _elem34:Formation;
                _elem34 = new Formation();
                _elem34.read(iprot);
                this.success.push(_elem34);
              }
              iprot.readListEnd();
            }
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for each (var elem35:* in this.success)        {
          elem35.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetFormations_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class IssueCommand_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("IssueCommand_args");
  private static const COMMAND_FIELD_DESC:TField = new TField("command", TType.STRUCT, 1);

  private var _command:Command;
  public static const COMMAND:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[COMMAND] = new FieldMetaData("command", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, Command));
  }
  {
    FieldMetaData.addStructMetaDataMap(IssueCommand_args, metaDataMap);
  }

  public function IssueCommand_args() {
  }

  public function get command():Command {
    return this._command;
  }

  public function set command(command:Command):void {
    this._command = command;
  }

  public function unsetCommand():void {
    this.command = null;
  }

  // Returns true if field command is set (has been assigned a value) and false otherwise
  public function isSetCommand():Boolean {
    return this.command != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case COMMAND:
      if (value == null) {
        unsetCommand();
      } else {
        this.command = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case COMMAND:
      return this.command;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case COMMAND:
      return isSetCommand();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case COMMAND:
          if (field.type == TType.STRUCT) {
            this.command = new Command();
            this.command.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.command != null) {
      oprot.writeFieldBegin(COMMAND_FIELD_DESC);
      this.command.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("IssueCommand_args(");
    var first:Boolean = true;

    ret += "command:";
    if (this.command == null) {
      ret += "null";
    } else {
      ret += this.command;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class IssueCommand_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("IssueCommand_result");



  public static const metaDataMap:Dictionary = new Dictionary();
  {
    FieldMetaData.addStructMetaDataMap(IssueCommand_result, metaDataMap);
  }

  public function IssueCommand_result() {
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("IssueCommand_result(");
    var first:Boolean = true;

    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

